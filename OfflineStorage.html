/**
* @fileoverview OfflineStorage - Camada de Persistência Local (IndexedDB Wrapper)
* Permite que o Guardião SEDF funcione sem internet e sincronize depois.
*/

const OfflineStorage = (function() {
const DB_NAME = 'GuardiaoSEDF_OfflineDB';
const DB_VERSION = 1;
const STORE_NAME = 'pending_sync';

/**
* Inicializa o banco de dados local
*/
async function initDB() {
return new Promise((resolve, reject) => {
const request = indexedDB.open(DB_NAME, DB_VERSION);
request.onupgradeneeded = (e) => {
const db = e.target.result;
if (!db.objectStoreNames.contains(STORE_NAME)) {
db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
}
};
request.onsuccess = (e) => resolve(e.target.result);
request.onerror = (e) => reject(e.target.error);
});
}

return {
/**
* Salva uma operação para sincronização futura
* @param {string} action - Ex: 'SAVE_DOC', 'LOG_AUDIT'
* @param {Object} data - Payload da operação
*/
savePending: async function(action, data) {
const db = await initDB();
return new Promise((resolve, reject) => {
const transaction = db.transaction([STORE_NAME], 'readwrite');
const store = transaction.objectStore(STORE_NAME);
const entry = {
action,
data,
timestamp: new Date().getTime(),
synced: false
};
const request = store.add(entry);
request.onsuccess = () => resolve(true);
request.onerror = () => reject(request.error);
});
},

/**
* Recupera todas as operações pendentes
*/
getPending: async function() {
const db = await initDB();
return new Promise((resolve, reject) => {
const transaction = db.transaction([STORE_NAME], 'readonly');
const store = transaction.objectStore(STORE_NAME);
const request = store.getAll();
request.onsuccess = () => resolve(request.result);
request.onerror = () => reject(request.error);
});
},

/**
* Remove item após sincronização de sucesso
*/
removeSynced: async function(id) {
const db = await initDB();
return new Promise((resolve, reject) => {
const transaction = db.transaction([STORE_NAME], 'readwrite');
store = transaction.objectStore(STORE_NAME);
const request = store.delete(id);
request.onsuccess = () => resolve(true);
});
}
};
})();